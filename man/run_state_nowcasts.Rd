% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/run_nowcasts.R
\name{run_state_nowcasts}
\alias{run_state_nowcasts}
\title{Run nowcasts for multiple states/locations}
\usage{
run_state_nowcasts(
  data,
  config,
  location_configs = NULL,
  locations = "all",
  nowcast_date = NULL,
  cumulative = TRUE,
  parallel = FALSE
)
}
\arguments{
\item{data}{A data frame of reporting data as returned by
\code{\link[=fetch_reporting_data]{fetch_reporting_data()}}, containing columns \code{reference_date},
\code{report_date}, \code{count}, \code{location}, and \code{signal}.}

\item{config}{A \code{nowcast_config} object to use as the default for all
locations.}

\item{location_configs}{Optional named list of \code{nowcast_config} objects
keyed by location code (e.g., \code{list(ca = config_ca, ny = config_ny)}).
These override the default \code{config} for specific locations.}

\item{locations}{Character vector. Either \code{"all"} for all available
locations in the data, or a character vector of specific location codes
(e.g., \code{c("ca", "ny")}). Default is \code{"all"}.}

\item{nowcast_date}{Date. The date to use as the nowcast date. Defaults to
the maximum report_date in the data.}

\item{cumulative}{Logical. If \code{TRUE} (the default), the input data is
assumed to be cumulative counts (as returned by \code{\link[=fetch_reporting_data]{fetch_reporting_data()}})
and will be converted to incremental counts using
\code{\link[=cumulative_to_incremental]{cumulative_to_incremental()}}. Set to \code{FALSE} if the data is already
incremental.}

\item{parallel}{Logical. Whether to use parallel processing via
\code{furrr::future_map()}. Default is \code{FALSE}.}
}
\value{
A data frame with columns:
\itemize{
\item \code{reference_date}: The reference date being nowcasted
\item \code{location}: Geographic identifier
\item \code{pred_count}: Predicted count (one row per draw)
\item \code{draw}: Draw number
\item \code{output_type}: Type of output ("samples" or "point")
}

The returned data frame has an attribute \code{failed_locations} containing
a character vector of any locations that failed to process.
}
\description{
Orchestrates nowcast generation for multiple geographic locations,
with optional parallel processing. Wraps each location in error handling
to continue processing even if individual locations fail.

This function handles the full pipeline from cumulative reporting data
(as returned by \code{\link[=fetch_reporting_data]{fetch_reporting_data()}}) to nowcast results, including
conversion to incremental counts internally.
}
\examples{
\dontrun{
# Fetch cumulative data for states
source <- delphi_epidata_source(target = "covid", geo_types = "state")
data <- fetch_reporting_data(source, reference_dates, report_dates)

# Single config for all locations
config <- nowcast_config()
results <- run_state_nowcasts(data, config, locations = c("ca", "ny"))

# Override config for specific locations
config <- nowcast_config(draws = 500)
location_configs <- list(
  ca = nowcast_config(max_delay = 5, draws = 500),
  ny = nowcast_config(max_delay = 7, uncertainty_model = "skellam", draws = 500)
)
results <- run_state_nowcasts(
  data, config,
  location_configs = location_configs,
  locations = c("ca", "ny", "tx")
)
# ca and ny use their specific configs, tx uses the default

# Check for failures
attr(results, "failed_locations")
}
}
